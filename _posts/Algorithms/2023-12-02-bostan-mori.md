---
layout: post
title: "Bostan-Mori 알고리즘: 선형 점화식에서 n번째 항 빠르게 구하기"
date: 2023-12-02 00:00:00 +0900
categories: Algorithms
use_math: true
---

* 다음 글은 이 논문을 기반으로 작성되었습니다. (다운로드 주의)
   - <https://inria.hal.science/hal-02917827v2/document>

$k$개의 상수 $c_0$, $c_1$, $\cdots$, $c_{k-1}$에 대해 초항이  $f_0$, $f_1$, $\cdots$, $f_{k-1}$이면서 다음과 같은 선형 점화식을 만족하는 수열 $\\{ f_n \\}$이 있습니다.

$$ f_{n+k} = c_0 f_n + c_1 f_{n+1} + \cdots + c_{k-1} f_{n+k-1} = \sum_{i=0}^{k-1} c_i f_{n+i} $$

**Bostan-Mori 알고리즘**은, 이러한 형식의 점화식과 초항이 주어졌을 때, $n$이 주어지면 $f_n$을 $O(\log n)$번의 $k$차 다항식 곱셈으로 계산하는 알고리즘입니다.

이 알고리즘의 시간복잡도는 다항식의 곱셈을 naive하게 구현했다면 시간복잡도가 $O(k^2 \log n)$이겠으나, 이 알고리즘의 진가는 여기에 FFT를 적용했을 때 나타납니다.

다항식의 곱셈을 FFT로 구현한다면 이 알고리즘의 시간복잡도는 $O(k \log k \log n)$으로 개선되어, PS 문제를 풀 때 선형 점화식의 값을 계산하지 못해 문제가 생길 일은 없습니다.

같은 문제를 푸는 알고리즘으로 PS에서 잘 알려진 것은 [Kitamasa법](https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/)입니다. 이 알고리즘은 $O(\log n)$번의 $k$차 다항식 곱셈 및 나눗셈으로 $f_n$을 구합니다.
Bostan-Mori와 비슷하게 보일 수 있겠지만, Kitamasa법은 다항식의 **나눗셈**도 사용한다는 차이점이 있습니다.

이로 인해 Kitamasa법은 $O(k \log k \log n)$의 시간복잡도로 만들기 위해 FFT를 적용할 때, 다항식의 나눗셈도 FFT를 활용한 버전으로 구현해야 하는데 [그 원리가 상당히 복잡하여](https://infossm.github.io/blog/2019/04/10/polynomial-division/) FFT의 적용이 쉽지 않습니다.

반면에 Bostan-Mori 알고리즘은 다항식의 곱셈**만**을 사용하므로, 다항식의 곱셈만 만들어 두면 $O(k \log k \log n)$ 버전이 바로 튀어나옵니다. 그러면서도 특별히 구현이 더 어렵다거나 한 점도 없습니다. 오히려 다항식의 나눗셈이 없어 $O(k^2 \log n)$ 버전도 구현이 쉽습니다.

# 유도


## 특성다항식

$$ f_{n+k} = c_0 f_n + c_1 f_{n+1} + \cdots + c_{k-1} f_{n+k-1} = \sum_{i=0}^{k-1} c_i f_{n+i} $$

이러한 형태의 선형 점화식에 대해 다음과 같은 다항식을 정의할 수 있습니다.

$$ \Gamma(x) := x^k - c_{k-1}x^{k-1} - c_{k-2}x^{k-2} - \cdots - c_1 x - c_0 = x^k - \sum_{i=0}^{k-1} c_i x^i $$

여기서 다항식 $\Gamma(x)$를 점화식의 **특성다항식**이라고 부릅니다.


## 생성함수

수열 $\\{ f_n \\}$에 대해 다음과 같은 다항식을 생각해봅시다.

$$ F(x) := f_0 + f_1 x + f_2 x^2 + f_3 x^3 + \cdots = \sum_{i\ge 0} f_i x^i $$

이 다항식을 수열 $\\{ f_n \\}$의 **생성함수**라고 부릅니다.
이 급수가 수렴하는지에 대한 여부는 일단 잊고, 생성함수라는 게 있다는 걸 받아들이기로 합시다.

$F(x)$의 $x^i$항의 계수를 $[x^i] F(x)$라 표기하면, $f_n = [x^n] F(x)$입니다.
이 값을 구하는 방향으로 접근해서 $f_n$의 값을 구하는 알고리즘을 구상해봅시다.


## 특성다항식과 생성함수의 성질

특성다항식의 계수를 뒤집은 다항식 $Q(x)$를 정의합시다.

$$ Q(x) := x^k \Gamma(1/x) = 1 - c_{k-1}x - c_{k-2}x^2 - \cdots - c_0 x^k $$

여기서 다항식 $P(x) := F(x)Q(x)$을 구해봅시다.
$P(x)$의 $k$차 이상의 계수를 계산해 보면 다음과 같습니다.

$$ [x^u] P(x) = f_u - c_{k-1}f_{u-1} - c_{k-2}f_{u-2} - \cdots - f_{u-k+1}f_{k-1} = 0 \qquad (u \ge k) $$

따라서 $P(x)$는 $k-1$차 다항식입니다.
이를 달리 말하면, $P(x)$를 $F(x)$와 $Q(x)$를 직접 곱함으로써 구하려 할 때, $F(x)$의 $x^{k-1}$차항까지만 따지면 된다는 말이기도 합니다.
따라서 다음 식이 성립합니다.

$$ P(x) = \big( f_0 + f_1 x + \cdots + f_{k-1} x^{k-1} \big) Q(x) \bmod x^k $$

따라서, $f_n$을 구하기 위해선 이렇게 정의된 두 다항식 $Q(x)$, $P(x)$에 대해 $P(x)/Q(x)$의 $n$차항의 계수를 구하면 됩니다.


## 다항식 분수의 $n$차항이라니??

여기서 이상하다는 생각이 들어야 합니다. $P(x)$는 $k-1$차 다항식이고, $Q(x)$는 $k$차 다항식입니다.
그러면 상식적으로 $P(x)/Q(x)$는 딱 나눠 떨어져서 단일 다항식으로 정리될 리가 없는데, 이 식의 $n$차항이라는 게 대체 무슨 소리일까요?

이런 이상한 논리가 등장하는 이유는, $F(x)$의 차수가 무한대이기 때문입니다.

다항식을 다항식으로 나눈 형태의 식을 **유리식**이라고 부르는데, 유리식은 단일 다항식으로 전개하여 둘이 같다고 놓을 수 있습니다.
이때 이 유리식이 약분되어 차수가 유한한 단일 다항식이 되지 못한다면, 대신 차수가 *무한한* 다항식으로 전개할 수 있습니다.

지금의 상황을 보면, $P(x)/Q(x)$가 다항식은 다항식인데 차수가 무한한 것이라 생각하면 이상하지만, 어떤 무한차 다항식 $F(x)$에 대해 $F(x)Q(x)$는 일반적인 유한차 다항식 $P(x)$가 나오긴 한다는 건 이상하지 않잖아요?
이거를 단순히 역으로 생각했다고 치고, $P(x)/Q(x)$를 유리식이라 하는 대신 차수가 무한한 다항식이라 생각하면, 그 식의 $n$차항을 구해야 한다는 말이 이상하지는 않죠?


## $F(x)$의 $n$차항 계수 구하기

아무튼, 그래서 $f_n$을 구하기 위해선 $[x^n]F(x) = [x^n] P(x)/Q(x)$를 구해야 합니다.

$$ f_n = [x^n] \frac{P(x)}{Q(x)} $$

우리의 목표는 구하고자 하는 식의 차수를 줄여서 $f_n$을 효율적으로 계산하는 것입니다.

우변의 분모 분자에 $Q(-x)$를 곱합시다.

$$ f_n = [x^n] \frac{P(x)Q(-x)}{Q(x)Q(-x)} $$

편의상 $U(x) := P(x)Q(-x)$로 정의합시다.

우변 분모의 $Q(x)Q(-x)$는 다항식이면서 우함수이므로, 여기에는 차수가 짝수인 항만 존재합니다.
따라서, 이 다항식의 모든 차수를 $2$로 나눈 다항식을 $V(x)$라 정의하면 $V(x^2) = Q(x)Q(-x)$라 할 수 있습니다.

$$ f_n = [x^n] \frac{U(x)}{V(x^2)} $$

이제 차수 $n$을 줄여볼 겁니다.

우변은 $U(x)$와 $1/V(x^2)$을 곱한 것으로도 생각할 수 있는데, 여기서 $1/V(x^2)$에 집중해봅시다.
$1/V(x^2)$은 우함수인 유리식이므로, 이 식을 차수가 무한한 다항식으로 전개하면 모든 항의 차수가 짝수일 겁니다.

따라서, $n$이 짝수라면 $U(x)/V(x^2)$의 $n$차항 계수는 $U(x)$에서 차수가 짝수인 항만 영향을 줄 것이고, 반대로 $n$이 홀수라면 $U(x)$에서 차수가 홀수인 항만 영향을 줄 겁니다.
이에 착안하여 $n$의 홀짝성에 따라 경우를 나눠볼 수 있습니다.

우선 $n$이 짝수라면 $U(x)$의 짝수차항만이 상관 있습니다. $U_i := [x^i] U(x)$를 정의하여, $U(x)$의 짝수차항만 남긴 다항식을 $U_e(x) := \sum_{i=0}^{k-1}U_{2i}x^i$이라 정의하면 다음 식이 성립합니다.

$$ f_n = [x^n] \frac{U_e(x^2)}{V(x^2)} = [x^{n/2}] \frac{U_e(x)}{V(x)} $$

반대로 $n$이 홀수라면 $U(x)$의 홀수차항만이 상관 있습니다. $U(x)$의 홀수차항만 남긴 다항식을 $U_o(x) := \sum_{i=0}^{k-1}U_{2i+1}x^i$이라 정의하면 다음 식이 성립합니다.

$$ f_n = [x^n] \frac{xU_o(x^2)}{V(x^2)} = [x^{(n-1)/2}] \frac{U_o(x)}{V(x)} $$

여기서 절반 정도로 줄어딘 차수를 새로운 $n$으로 잡고, 유리식의 분모 분자를 각각 새로운 $Q(x)$, $P(x)$로 잡으면, 문제의 차수가 절반 정도로 줄어들게 됩니다.
즉, 목표를 달성했습니다.

이 작업을 구하고자 하는 항의 차수가 $0$이 될 때까지 반복하면, 최종적으로 다음과 같은 형태의 식이 남습니다.

$$ f_n = [x^0] \frac{P(x)}{Q(x)} $$

우변의 상수항은 단순히 $x$에 $0$을 대입하면 얻을 수 있습니다. 따라서, 다음과 같은 결론을 얻게 됩니다.

$$ f_n = \frac{P(0)}{Q(0)} $$

차수를 절반으로 줄이는 한 번의 작업에, $U(x)$와 $V(x^2)$을 구하는 것으로 다항식의 곱셈이 두 번 일어납니다.
$n = 0$이 될 때까지 이를 반복하면 총 $O(\log n)$번 반복되므로, 다항식의 곱셈을 $O(\log n)$번 수행하여 $f_n$을 구할 수 있다는 결론이 만들어집니다.
이 알고리즘이 바로 **Bostan-Mori 알고리즘**입니다.


## 분모 덜어내기

이 식에는 문제가 하나 있습니다.
최종적인 식이 분수의 형태를 갖기 때문에, 문제가 만약 $f_n$을 $m$으로 나눈 나머지를 구하라고 요구했으면 $Q(0)$의 $\textrm{mod } m$에 대한 곱셈 역원이 존재하는지가 문제가 됩니다.
그러면 Bostan-Mori는 모듈로가 소수일 때에만 적용이 가능하고, 그조차도 $Q(0) = 0$이면 사용이 불가능할까요?

이게 문제가 될 것 같지만, 사실 문제가 되지 않습니다. Bostan-Mori는 모듈로가 소수가 아니어도 적용이 가능합니다.

$Q(x)$의 정의에 의해 초기에는 $Q(0) = 1$입니다. 그리고 한 번의 작업에 $Q(x)$는 $Q(\sqrt{x})Q(-\sqrt{x})$로 교체됩니다.
이 새로운 $Q(x)$에 대해 $Q(0)$의 값은 기존 $Q(x)$에 대해 ${Q(0)}^2$입니다.
초기에 $Q(0) = 1$이었으므로, 이후 루프를 계속 반복해도 $Q(0)$은 항상 $1$입니다.

따라서, 마지막에 $f_n = P(0)/Q(0)$이라는 식은 다음과 같이 변형할 수 있습니다.

$$ f_n = P(0) $$

즉, $f_n$은 $P(x)$의 상수항입니다. $f_n$을 이렇게 계산하면 모듈로 곱셈 역원을 조금도 걱정하지 않아도 됩니다.


# 알고리즘

위 설명을 정리하면, 최종 알고리즘은 다음과 같이 구성됩니다.
1. $Q(x) = 1 - c_{k-1}x - c_{k-2}x^2 - \cdots - c_0 x^k$과 $P(x) = (f_0 + f_1x + \cdots + f_{k-1}x^{k-1})Q(x) \bmod x^k$을 정의합니다.

1. $n \ge 1$인 동안 다음 작업을 반복합니다. 이 루프는 $O(\log n)$번 실행됩니다.

   1. $U(x) = P(x)Q(-x)$를 계산합니다.

   1. $Q(x)Q(-x)$는 짝수차항만 있는 다항식입니다. $V(x^2) = Q(x)Q(-x)$을 정의합니다. 즉, $V(x)$는 $Q(x)Q(-x)$의 모든 차수를 $2$로 나눈 것입니다.

   1. $U_i$를 $U(x)$의 $x^i$항 계수라 정의합니다. $n$이 짝수라면 $P(x)$를 $\sum_{i=0}^{k-1}U_{2i}x^i$로, 홀수라면 $\sum_{i=0}^{k-1}U_{2i+1}x^i$로 교체합니다.

   1. $Q(x)$를 $V(x)$로 교체합니다.

   1. $n$을 $\lfloor n/2 \rfloor$으로 교체합니다.

1. $P(x)$의 상수항이 $f_n$의 값입니다.

위 알고리즘에서 $k$차 다항식의 곱셈이 1, 2-1, 2-2 과정에서 나타나는데, 이들을 전부 FFT 곱셈으로 구현하면 전체 시간복잡도는 $O(k \log k \log n)$이 됩니다. FFT를 사용하지 않으면 $O(k^2 \log n)$이 됩니다.
