---
layout: post
title: "(스포 주의) ABC335 - 풀이 및 후기"
date: 2024-01-07 00:30:00 +0900
categories: AtCoder
use_math: true
---

[대회 링크](https://atcoder.jp/contests/abc335)

이 글에는 대회 문제들에 대한 스포일러가 들어 있으므로 열람에 주의 바랍니다.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

# A. 202~~3~~
*b5 #string

하면 된다.

# B. Tetrahedral Number
*b4 #bruteforcing

$O(N^3)$ 브루트포스를 수행하면 된다.

# C. Loong Tracking
*s2 #deque

용의 머리와 몸통을 덱에 저장하면 모든 쿼리를 $O(1)$ 안에 수행할 수 있다. 난이도에 S2를 준 것은 단순히 풀이에 덱이 들어가기 때문이다.

Python에서 collections의 deque 자료구조를 사용할 경우, 크기 $N$인 deque에서의 인덱싱이 $O(N)$임에 주의해야 한다. 직접 리스트 기반의 덱을 구현해서 이를 해결할 수 있다.

# D. Loong Takahashi
*s3 #implementation

<center><figure>
    <img src="/assets/posts/2024-01-07-abc335/1.png" width=130>
</figure></center>

여러 방법이 있는데, 위와 같이 안에서부터 돌아나가는 것을 구현하는 코드는 아래와 같다.

```py
grid = [[0] * n for _ in range(n)]
dr, dc = [0, 1, 0, -1], [-1, 0, 1, 0]
cnt = 0
r, c = n // 2, n // 2
d = 0
for i in range(n):
    for _ in range(2 if i != n else 1):
        for _ in range(i + 1):
            grid[r][c] = cnt
            cnt += 1
            r += dr[d]
            c += dc[d]
        d = (d + 1) % 4
```

이렇게 하고 가운데 부분을 `T`로 바꿔서 출력만 하면 된다.


# E. Non-Decreasing Colorful Path

그래프의 모든 간선 $(u,\ v)$에 대해, $A_u < A_v$면 간선에 $u \leftarrow v$의 방향을 주고, $A_u = A_v$면 양방향으로 간선을 놔둠으로써 새로운 그래프를 만들자.
새로 만든 그래프는 방향 그래프로 정점 $1$에서 $N$까지 도달 가능하다는 보장이 없는데, 도달 불가능하다면 가중치가 단조증가하는 경로가 없다는 뜻이므로 최대 점수가 $0$점이라고 판정하면 된다.

각 정점에 대해, 그 정점에 도달할 때의 최대 점수를 저장하는 배열을 채워서 정답을 구할 생각을 해보자.
기호를 써서, 매 순간 정점 $v$에 도달할 때의 최대 점수를 $S_v$라고 하자.

만약 모든 정점의 가중치가 다르다면 단순히 가중치가 작은 것부터 순서대로 $S_v$의 값을 채워나감으로써 모든 $S_v$를 구할 수 있다. 가중치가 같은 정점이 있더라도, 새로 만든 그래프에서 서로 오가는 길이 없다면 동일한 발상을 적용할 수 있다.

문제는 서로 오갈 수 있는 가중치 같은 정점이 있는 상황이다. 이 경우 그 정점이 서로의 $S_v$를 공유하기 때문에 따로 적절히 처리해줘야 한다. 이 부분을 처리하는 방법이 두 가지 있는데, 대회에서 본인이 생각한 방식보다 대부분의 다른 분들이 떠올린 방식이 훨씬 쉬운 것 같다. 그래도 두 가지 모두 공유한다.

## 풀이 1 (본인 풀이)
*p5 #dijkstra

다음과 같은 우선순위 큐를 활용해서 다익스트라 비슷한 것을 수행하는 알고리즘을 생각하자. 이 우선순위 큐는 정점을 담는데, 정점의 가중치에 대한 최소 힙이다. 단, 가중치가 같은 정점이 여러 개가 있을 경우 $S$ 값이 가장 큰 것을 먼저 뽑는다.

이러한 우선순위 큐를 사용하면, 가중치가 다른 정점들에 대해선 가중치가 작은 것부터 우선순위 큐에서 나오기 때문에 $S$ 값이 가중치 작은 정점부터 채워진다.

가중치가 같은 정점들이 있다면, 그중에선 $S$ 값이 큰 것이 먼저 나오게 된다. 따라서, 잘 생각해보면 큐에서 먼저 나온 정점은 그 가중치를 가진 정점들 중 $S$ 값을 가장 크게 유지할 수 있는 정점이며, 이로부터 도달할 수 있는 다른 가중치 같은 정점들로 $S$ 값이 퍼지게 된다. 따라서 이 우선순위 큐를 사용하면 가중치가 같은 정점들로 적절하게 $S$ 값을 퍼트릴 수 있다.

구체적인 알고리즘은 다음과 같다.

1. 정점 $v$에 대해 $(-A_v, S_v, v)$를 담는 최대 힙을 만든다.
    - 단, 정점 $v$를 힙에 넣은 다음 이를 꺼내기 전에 실제 $S_v$가 업데이트 될 수 있지만, 최대 힙에 이미 들어간 $S_v$의 값은 건드리지 않는다. 일반적인 $O(E\log E)$ 다익스트라와 유사하다.
2. 모든 값이 False로 초기화된 방문 배열 $C$와 모든 정점의 점수를 담는 점수 배열 $S$를 초기화한다. $S$는 초기에 $S_0 = 1$이고, 다른 정점에 대해선 None이다.
3. 힙에 $(-A_0, 1, 0)$을 넣고, 힙이 빌 때까지 다음 루프를 반복한다.
    1. 힙에서 $(-A_v, s, v)$를 꺼낸다.
    2. $C_v$가 True라면 continue. 그렇지 않다면 $C_v$를 True로 바꾼다.
        - $C_v$가 False였다면 $s = S_v$이고, True였다면 $s \le S_v$이다.
        - $s < S_v$면 continue 시켜도 되지 않나 싶을 수 있으나 이러면 무한루프에 빠진다. $C_v$가 True였다면 $s < S_v$가 아니라 $s \le S_v$인 것이 그 이유이다.
    3. $v$에 인접한 정점 $u$에 대해…
        1. $A_u < A_v$면 continue.
            - 명시적으로 상술한 그래프를 따로 만들었다면 필요 없는 과정이다.
        2. $A_v = A_u$면 $n \leftarrow s$, $A_v > A_u$면 $n \leftarrow s+1$.
        3. $S_u$가 None이거나 $n$보다 작으면 $S_u \leftarrow n$.
        4. 힙에 $(-A_u, S_u, u)$를 넣는다.
4. $S_{N-1}$이 None이라면 0, 아니라면 $S_{N-1}$이 정답이다.

알고리즘의 시간복잡도에 대한 증명은 다익스트라에서와 동일하다. 방문 배열 $C$ 덕분에 모든 정점은 한 번씩만 방문되고, 각 정점에서 나가는 간선이 힙에 한 번씩만 들어가게 된다. 따라서 총 시간복잡도는 다익스트라와 동일한 $O(E \log E)$이다.

복잡해 보이지만 실제로 구현하면 코드가 상당히 짧다. 위 알고리즘이 복잡해 보이는 것은 한 줄 한 줄을 문장으로 옮기면서 부가 설명을 붙인 것이기 때문이다.

대회에선 최대 힙에 $(-A_v, v)$만을 넣어서 가중치 같은 정점을 잘못 관리하여 두 번 틀렸다. 이 풀이가 구현은 간단하지만 그래도 풀이 2가 떠올랐다면 그것대로 짜는 것이 훨씬 정확했을 것 같다. 조금 아쉽지만 이 풀이도 만족스럽다.

## 풀이 2 (다른 풀이)

*g2 #disjoint_set #dag #dp

나중에 ygonepiece님 등 다른 분들과 얘기하면서 알게 된 풀이인데, 이해하기는 이쪽이 확실히 더 쉬운 것 같다. 정확한 구현이 쉬운 것도 이것이다. 풀이 1의 장점은 코드가 짧다 한 가지뿐인 것 같다.

유니온 파인드를 사용해서 서로 도달 가능한 정점을 묶어버리자. 이는 모든 간선 $(u,\ v)$에 대해 $A_u = A_v$면 유니온 파인드에서 $u$와 $v$를 하나의 그룹으로 묶어버림으로써 쉽게 된다. 그리고, 이 묶인 그룹 각각을 유니온 파인드에서 그룹의 루트가 대표한다고 생각하자.

이렇게 하면 만들어지는 그래프는 DAG가 되며, 인접한 모든 정점의 가중치가 달라진다. 따라서 이에 대해 DAG DP를 수행하면 모든 $S_v$를 계산할 수 있다.


# F. Hop Sugoroku

*p4 #dp #number_theory

편의상 모든 인덱스는 0-based로 바꿔서 기술한다. 이 문제는 결국 $u$번 정점에서 오른쪽으로 $A_u$의 배수만큼 이동할 수 있을 때 정점 $0$부터 시작해서 아무 데로나 이동하는 경로의 가짓수를 구하라는 문제이다.

$O(N^2)$ 풀이는 구상하기 쉽다. $DP[v]$를 정점 $v$에 도착하는 경로의 가짓수라고 하면 다음과 같은 식을 세울 수 있다.

$$
DP[v] = \sum_{\substack{
u\ \equiv\ v \bmod A_u \\
0\ \le\ u\ <\ v
}} {DP[u]} \ ; \qquad DP[0] = 1
$$

이를 제곱근의 성질을 활용해 $O(N \sqrt{N})$으로 개선시킬 수 있다.

$DP[v]$를 순차적으로 계산한다고 하자. $A_u \le \sqrt{N}$인 $u$만 고려했을 때, 2차원 배열 $B_{a,\ x}$를 $v$ 미만의 정점 $u$ 중 $A_u = a$이고 $u \% A_u = x$인 $u$에 대해 $DP[u]$의 합이라고 하면, $DP[v]$에$\sum_{a \le \sqrt{N}} {B_{a,\ v \% a}}$를 먼저 더해준다. $A_u < \sqrt{N}$만 고려하고 있기 때문에 나이브한 덧셈을 써도 이 부분의 시간복잡도가 $O(\sqrt{N})$이다.

다음으로 $A_u > \sqrt{N}$인 $u$를 고려하자. 2차원 리스트 $C$에 대해 $C_v$를 $v$번 정점에 갈 수 있으면서 $A_u > \sqrt{N}$인 정점 $u$의 리스트라고 하면 $DP[v]$에 $\sum_{u \in C_v} DP[u]$를 더해준다. 그러면 $DP[v]$의 값이 구해진다. $A_u > \sqrt{N}$만 고려하고 있기 때문에 나이브한 덧셈을 써도 $C_v$의 길이가 $O(\sqrt{N})$이므로 시간복잡도도 $O(\sqrt{N})$이다.

마지막으로 다음 $DP$값을 구할 수 있도록 $B$, $C$를 업데이트 해줘야 한다. $A_v \le \sqrt{N}$이면 정점 $v$의 정보를 $B$에 업데이트 해주기 위해 $B_{A_v,\ v \% A_v}$에 $DP[v]$를 더한다. $A_v > \sqrt{N}$이면 정점 $v$의 정보를 $C$에 업데이트 해주기 위해 $w \equiv v \bmod A_v$, $w>v$인 모든 $w$에 대해 $C_w$에 $v$를 추가한다. 이 경우 $w$의 값은 $O(\sqrt{N})$개이므로 이 과정의 시간복잡도는 $O(\sqrt{N})$이다.

마지막으로 모든 $DP[v]$의 합을 구하면 정답이 나온다. 루프의 모든 절차가 $O(\sqrt{N})$이고 이를 $N$번 반복하므로 전체 시간복잡도는 $O(N \sqrt{N})$이다.

다만 jh01533님께 들어보니 $O(N^2)$ 풀이를 빡빡하게 최적화해서 clang의 가호를 받으면 정답을 받는다곤 한다.


# G. Discrete Logarithm Problems

*? #number_theory #bruteforcing #flt

$3$ 이상의 소수 $P$에 대해 모듈로 $P$ 아래에서 임의의 정수 $2 \le x < P$는 $x^{k} \equiv 1 \bmod P$인 양의 정수 $k$를 가진다. 이 양의 정수 중 가장 작은 것을 $x$의 모듈로 $P$에 대한 위수(order)라고 하며, 모든 양의 정수 $k$는 이 위수의 배수로 나타난다. 공식적인 표기는 아니지만 이 섹션에선 편의상 $x$의 모듈로 $P$에서의 위수를 $f(x)$라고 표기하겠다.

페르마의 소정리에 따르면 임의의 정수에 대해 $x^{P-1} \equiv 1 \bmod P$이다. 따라서 모든 위수는 $P-1$의 약수로 나타나며, 이 덕분에 어떤 정수 $x$의 위수를 구하는 시간복잡도 $O(\sqrt{P})$의 알고리즘을 생각할 수 있다. ($P$가 소수가 아니라면 아래 알고리즘의 모든 $P-1$을 $\phi(P)$로 바꾸면 된다.)

1. $P-1$을 소인수분해한다. 그 결과를 $P-1 = {p_1}^{e_1} {p_2}^{e_2} \cdots$라고 하자.
2. $r \leftarrow P-1$
3. $P-1$의 각 소인수 $p_i$에 대해…
    1. $e \leftarrow P-1$
    2. $p_i \mid e$인 동안… (이 루프는 최대 $e_i$번 실행된다)
        1. $e \leftarrow e / p_i$
        2. 만약 $x^e \equiv 1 \bmod P$라면 $r \leftarrow r / p_i$
        3. 그렇지 않다면 루프를 탈출한다.
4. 그러면 $f(x) = r$이다.

$P$가 소수이기 때문에, 어떤 두 정수 $a,\ b \in [2, P)$에 대해 $a^k \equiv b \bmod P$라는 사실은 $f(a) \mid f(b)$라는 사실과 동치이다. 이는 $P$가 소수이므로 위수가 $P-1$인 수가 반드시 존재하며, $a$와 $b$는 모두 이 수의 거듭제곱으로 표현할 수 있다는 사실에서부터 나온다. 이 문제는 따라서 $f(A_i) \mid f(A_j)$인 모든 $(i,\ j)$의 개수를 세는 문제로 환원된다.

$f(x)$는 $P-1$의 약수이므로 가능한 값의 가짓수가 $O(\tau(P-1)) \sim O(P^{1/3})$이다. 따라서, $f(A_i)$들을 그 값에 따라 나눠서 각각의 개수를 세고 나면 $O(\tau(P-1)^2) \sim O(P^{2/3})$ 시간복잡도의 알고리즘을 써서 $f(A_i) \mid f(A_j)$인 모든 $(i,\ j)$의 개수를 브루트포스처럼 셀 수 있다.

뭐 이런 걸 ABC에 내나 싶다. 위수를 구하는 것 외의 부분은 다 G번 치고는 간단한, solved.ac에서 소위 말하는 “레이팅 파밍 문제” 같은 문제였고, 대회용으로 쓰기엔 좀 아쉬운 문제였다.

대회에서 보고 “아 이거 원시근이랑 위수 쓰는 문제다” 싶어서 곧바로 rkm님 블로그 글 검색해서 코드 짰는데, 정수론 부분을 제외한 알고리즘을 짠 후 남은 시간인 15분은 그러기에 너무 짧았다. 대회가 끝나고 나서야 좀 더 생각해보고 사실 위수만 필요하다는 사실을 알았다.

대회에선 $f(A_i) \mid f(A_j)$인 경우만 보면 된다는 사실을 제외하곤 전부 생각해냈는데, 이 부분을 생각하지 못해 원시근까지 구해야 한다고 생각했다. 조금 아쉽지만 애초부터 rated 참가자보고 풀으라고 내는 문제는 아니었기 때문에 미련이 크게 남지는 않는다. 약간은 남는다…