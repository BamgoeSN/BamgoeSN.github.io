---
layout: post
title: "[BOJ 1165] 단어퍼즐"
date: 2023-09-16 17:00:00 +0900
categories: BOJ
use_math: true
---

# 문제

[1165번: 단어퍼즐](https://www.acmicpc.net/problem/1165)

# 풀이

## 코드 길이 제한이 없다면

길이 제한이 없는 버전의 문제는 [13502번](https://www.acmicpc.net/problem/13502) 문제가 따로 있습니다.
이 문제는 저는 `dict.txt`에 있는 모든 문자를 하나의 트라이에 넣고, 퍼즐 격자를 하나씩 보면서 DFS를 돌려보며, 트라이 위에 없는 노드에 접근하려 하면 탐색을 더 깊이 하지 않는 식으로 단어를 찾았습니다.

격자의 크기가 별로 크지 않고, `dict.txt`에 있는 문자열의 길이가 그다지 길지 않은 데다, 방문했던 칸을 다시 방문할 수 없다는 조건이 있는 덕분에, 의외로 이 부분은 브루트포스 비슷하게 해도 별문제 없습니다.
더 이상 찾아봐도 단어가 나오지 않음이 확실한 것만 판정해서 백트래킹 해주면 되는데, 저는 이걸 트라이로 했지만 다른 더 쉬운 방법이 있다면 그것대로 하는 게 더 좋을 겁니다. 저는 당장 떠오르는 게 딱히 없네요.

하지만, `dict.txt`의 크기가 200kB가 넘는 수준이기 때문에, 65535B의 코드 길이 제한이 있는 문제에 `dict.txt`의 내용을 통째로 집어넣는 것이 불가능합니다.
`dict.txt`에 있는 모든 단어의 길이 합을 세어보면 187754글자로, 이를 코드 안에 그대로 넣는 방법은 불가능합니다.

이 문제를 어떻게 해결할까요?
가장 먼저 떠오르는 방법은 `dict.txt`를 최대한 압축해서 코드 길이 안으로 데이터의 양을 줄이는 것입니다.

그걸 한번 그대로 해봅시다.

## 겹치는 데이터는 한 번만 저장

데이터 압축에서 가장 쉽게 생각할 수 있는 부분은, 정보가 불필요하게 반복적으로 등장할 때 이를 줄여보는 겁니다. `dict.txt` 파일을 열어서 반복적으로 등장하는 부분이 있는지 관찰을 해봅시다.

`dict.txt`의 모든 단어가 사전 순으로 정렬되어 있어서 관찰하기 좀 더 쉬운데, 인접한 두 단어 사이에 공통 접두사로 겹치는 부분이 꽤 많다는 것을 알 수 있습니다.
따라서, 인접한 두 단어의 공통접두사는 길이만 저장한다는 발상을 할 수 있습니다.

예시로 `dict.txt`의 첫 여섯 단어를 보면 `AARGH, AARON, ABABA, ABACK, ABANDON, ABANDONED`인데, 인접한 문자열로 묶었을 때 공통 접두사의 길이를 세어보면 3, 1, 3, 3, 7입니다.
첫 단어를 제외하고 모든 단어를, 그 앞의 단어와의 공통 접두사 길이 + 그 나머지 부분 형태로 변환한다면 위 여섯 단어는 `AARGH, 3ON, 1BABA, 3CK, 3NDON, 7ED`가 됩니다.
여기서 반점(,)과 띄어쓰기를 제거하면 `AARGH3ON1BABA3CK3NDON7ED`가 되겠네요. 압축 전에 모든 단어 길이의 합이 36글자이던 게 압축 후 24글자로 줄어들었습니다.

위 예시만 보면 압축률이 25% 정도로 그다지 효율적이진 않아 보일 수 있습니다.
하지만 실제로 문제에서 주어진 `dict.txt`를 위 방법으로 압축해 보면, 압축 후 문자열의 길이가 90854글자로 줄어듭니다. 절반 정도가 줄어든 셈이죠.

그렇지만 아직 65535B의 길이 제한이 집어넣기에는 무리가 있는 크기입니다.
다음으로 간단히 떠올릴 만한 압축 방법을 고려해 봅시다.

## 허프만 코딩

**허프만 코딩**은 주어진 문자열을 0과 1로만 이루어진 이진 코드로 압축하는 알고리즘으로, 문자열을 압축해서 하드코딩해야 한다고 할 때 가장 간편하게 떠올릴 방법입니다.
간편하다는 얘기는 떠올리는 난도가 낮다는 의미가 아니라, 아무 문자열에나 깊은 생각 없이 때려 박을 수 있다는 의미로써 간편하다는 말입니다.

허프만 코딩이 구체적으로 무엇인지, 어떻게 동작하는지, 압축과 해제가 어떻게 이루어지는지는 여기서 다루지 않겠습니다.
학부 알고리즘 과목에서도 자주 가르치는 내용인 만큼, 이에 대해선 매우 자세하게 소개한 자료들이 많습니다. ([주니온TV 박사님의 허프만 코드 강의](https://youtu.be/IDxnHM01fZY?si=17LnmiR823c6wnwV))

이 방법대로 위 문자열을 압축하면 하나의 거대한 이진 코드가 만들어집니다. 제가 압축을 수행해 본 결과 총 425536비트, 즉 53192바이트의 데이터가 나왔습니다.
크기만 보면 이제 코드 길이 제한 안에 압축한 데이터를 집어넣을 수 있는 수준입니다.

하지만 이렇게 얻은 코드는 하나의 문자열이 아닌 이진 코드입니다. 즉, 이 데이터를 코드 안에 반영할 방법을 이제 생각해야 한다는 뜻입니다.
이진 코드는 0과 1의 배열일 뿐인데, 이를 그대로 정수 배열로 넣거나 16진법으로 변환해서 넣으면 길이 제한에 걸립니다.

그렇기 때문에 이진 코드를 코드에 집어넣을 다른 방법을 생각해야 하는데, 저는 문자열을 사용해서 데이터를 하드코딩했습니다.
이제 이진 코드를 하드코딩 가능한 문자열로 변환하는 방법을 알아봅시다.

## 이진 코드를 아스키코드로 변환

이진 코드를 하드코딩하기 위해 데이터를 아스키코드 문자열로 저장할 겁니다.

아스키코드는 하나의 8비트 정수를 문자에 대응시키는 인코딩 방식으로, 하나의 문자가 0 이상 127 이하의 정수로 표현됩니다.
즉, 하나의 문자가 7개의 비트를 차지하며, 가장 큰 자릿수의 비트는 항상 0입니다.
이 인코딩에 허프만 코드로 압축된 이진 코드를 맞춰 집어넣는다면 문자열로 표현하는 것이 완료됩니다.

하나의 문자에 8개의 비트를 알차게 사용할 수 있는 인코딩을 사용할 수 있다면 좋겠지만, 그건 제가 아는 선에선 불가능합니다.
UTF-8 인코딩은 가변 인코딩으로, 하나의 문자가 여러 개의 바이트를 차지할 수 있고, UTF-8으로 인코딩된 문자열은 임의의 바이트를 포함할 수 있습니다.
하지만, 둘 이상의 바이트를 차지하는 문자를 인코딩할 때의 UTF-8의 규칙에 의해, 아무 바이트열이나 그대로 갖다 박는다고 유효한 UTF-8 문자열이 되지 않습니다.
따라서, 비트열이 어떻게 되어 있더라도 유효한 문자열이 나올 수 있도록 하나의 문자에 7개의 비트를 사용하는 아스키 인코딩을 사용합니다.

구현은 모든 비트를 7개씩 쪼개서 바이트열을 만든 다음 이를 문자열로 저장하면 끝입니다.
하나의 문자에 7개의 비트만을 사용했으므로 이는 유효한 아스키코드입니다.
이 문자열은 저의 경우에는 계산해 보니 60791바이트가 나왔습니다. 비트를 7개 단위로 나누다 보니 크기가 좀 커졌지만, 다행히도 여전히 코드 길이 제한 안에 들어오는 크기입니다.

이렇게 만든 아스키코드는 실제로는 이스케이프 코드를 사용해야 하는 문자가 잔뜩 들어있습니다. 개행 문자와 같이 말이죠.
따라서 이 문자열을 코드에 저장하려면 raw string 문법을 사용해야 합니다. 언어마다 raw string 문법이 다 있으니 검색해서 활용하면 됩니다.

이제 이 문자열을 코드에 그대로 넣고, 남은 제한 안에서 복호화 코드를 넣어서 DFS를 돌리면 끝입니다.
남은 크기가 4500 글자 정도 되는데, 이 정도면 할만한 수준입니다.

다만...

## 그냥은 못 넣는다

앞서 문자열이 유효한 아스키코드면 하드코딩이 가능하다고 했는데, 예외가 두 가지 있습니다. 하나는 **캐리지 리턴(CR)**이고, 다른 하나는 **널 문자**입니다.

캐리지 리턴의 경우, 문자열 안에서 CR 뒤에 개행 문자가 오지 않는 것을 "bare CR"이라고 하는데, bare CR은 코드에서 문자열 리터럴 안에 넣지 못합니다.
CR을 문자열에 포함할 경우 `\r`과 같은 이스케이프 코드를 사용해야 합니다.

널 문자의 경우엔 코드에 포함하여 컴파일할 땐 문제가 생기지 않습니다.
다만, 코드 작성 후 코드를 복사하여 제출창에 붙여넣으려고 할 때, 복사한 모든 문자열이 붙여넣어지지 않는 것을 확인할 수 있습니다.

Windows 10 기준으로 널 문자가 포함된 문자열을 복사하면 첫 번째 널 문자 직전까지만 클립보드에 들어가는 것으로 보입니다.
그 때문에 이 코드를 BOJ에 제출할 수 있으려면 널 문자도 코드에서 제거해야 합니다.

그럼, 이 문제는 어떻게 해결할까요? CR과 널 문자를 다른 문자로 치환하여 하드코딩한 후, 복호화 전에 이들을 다시 원래대로 되돌리면 됩니다.

다만 여기서 CR을 `\r`으로, 널 문자를 `\0`으로 치환하는 방법은 통하지 않습니다.
두 경우 모두 치환한 결과가 아스키코드로 이뤄져 있어, 압축한 결과물 안의 CR이나 널 문자가 아닌 위치에서 우연의 산물로 `\r`과 `\0`이 등장했을 수도 있기 때문입니다.
그러면 리터럴로 저장했던 `\r`과 `\0`을 CR과 널 문자로 변환하는 과정에서 잘못된 변환이 일어날 수도 있습니다.

이 문제는, CR과 널 문자를 *2바이트를 차지하는 적당한 UTF-8 문자*로 치환하면 해결됩니다.
2바이트 크기의 UTF-8 문자는 첫 번째 바이트가 128 이상입니다. 따라서 다른 아스키코드와 절대 겹치지 않아 잘못된 변환이 일어날 수 없습니다.
저 같은 경우는 CR을 £로, 널 문자는 И으로 치환했습니다.

이제 하드코딩 가능한 형태로 문자열 압축이 완료되었습니다.
이 문자열을 하드코딩하여, 코드 안에서 압축을 해제하고, DFS를 통해 단어 퍼즐에 등장하는 모든 단어를 찾아내면 됩니다.

## 티어에 대한 여담

현재 이 문제의 티어가 D4인데, 제가 풀었을 당시엔 D3이었고 그 즉시 기여가 하나 추가되어 D4로 내려왔습니다.
이 문제에 필요한 발상은 인접한 단어의 공통 접두사를 저장하겠다는 게 전부이고, 그 외의 부분은 생각 없이 허프만 코딩을 박는다거나, 하드코딩을 시도했을 때 발생하는 오류를 회피하는 것만 하고 나면 문제가 해결됩니다.
개인적으로 다이아급 문제는 절대 아니고, 플래티넘 중상위권 정도가 적절하다고 생각합니다.

치팅하기 힘들으라고 코드 하나도 없이 말로만 썼습니다 :) 모르고 보면 이해 못 할 생략도 좀 있는데, 잘 모르는 내용이 있다면 직접 자료를 찾아가면서 알아보시기를 바랍니다. 그래도 필요한 지식은 다 언급했어요. 화이팅