---
layout: post
title: "[BOJ 2618] 경찰차"
date: 2021-07-17 00:30:00 +0900
categories: ["BOJ"]
tags: ["DP"]
katex: true
description: " "
---

[문제](https://www.acmicpc.net/problem/2618)

[solved.ac Class 6](https://solved.ac/search?query=in_class:6)에 포함되어 있는 문제이다.

## 풀이과정

문제를 보고 거의 바로, 소위 말하는 "DP문제 느낌"을 받긴 했지만, 실제로 DP식을 생각해내고 풀어내는 데에는 며칠이 걸렸다.

### 첫 번째 접근

처음에는 그리디하게 접근하자는 생각으로, 일단 각 사건이 발생했을 때 가장 가까운 경찰차가 사건을 처리하는 경우를 생각해봤다.  
그리디를 활용할 생각을 했으므로, 자연스레 그리디가 맞는지 증명하거나 반증할 생각을 하게 됐다.  
다만, 바로 아이디어가 떠오르지 않아서, 일단 코드를 쓰면서 생각하기로 했다.

코드를 쓰다보니 두 경찰차에게서 거리가 같을 때 어느 경찰차를 선택해야 하는지 결정하기 어렵다는 문제에 봉착했다.
그래서 이런저런 예시를 생각해보다가... 그리디하게 접근했을 때 발생하는 반례를 찾았다.

```
10
4
2 2
5 5
6 6
1 1

정답
16
1 2 2 1

그리디하게 접근할 경우
22
1 1 1 1
```

위 예시의 경우, 마지막에 발생하는 사건이 초기 경찰차1의 위치와 가깝기 때문에, 최대한 경찰차1은 그 주변의 사건을 처리하는 것이 유리하고, 나머지 사건은 경찰차2에 맡기는 것이 좋다.  
이와 같은 경우가 존재할 수 있기 때문에, 항상 가까운 경찰차가 사건을 처리하는 것은 때로는 최선의 선택이 아님을 알 수 있다.

이 접근을 생각한 당일은 이 사실을 깨달은 후, 그래도 어거지로 코드를 써서 제출한 다음, 당연히 오답을 받고 다음에 더 생각하기로 하고 넘겼다.

### 두 번째 접근

조금 더 생각해보니 각 사건을 맡을 때 경찰차가 이동하는 거리는 바로 직전 경찰차의 배치에 따라 결정된다는 점을 알았고, 이에 착안하여 DP로 접근할 생각을 하였다. 이 생각을 그리디로 접근하고 다음 날에 떠올렸다.

처음에는 앞서 활용한 그리디한 접근에서 크게 벗어나지 않고, 만약 지금 당장만 생각하는 것이 안 먹힌다면 한 수 앞을 더 보면 되지 않을까? 라는 생각을 하였다.  
이후 이 발상을 그대로 코드로 옮겨 제출해봤지만, 오답이 나왔다.  
사실 그럴 만한 것이, 그리디한 접근이 안 먹힌 이유가 결국 이전 상황을 넓게 보지 못 해서였는데, 한 칸 더 앞서서 본다고 해서 정답이 나올 리가 없었다.  
반례도 동일한 아이디어로 만들 수 있었다. 만약 한 수 앞을 못 보던 걸 볼 수 있게 됐다면, 두 수 앞을 봐야 하는 상황을 만들면 됐다.

```
10
6
2 2
3 3
5 5
2 2
5 5
1 1

정답
18
1 1 2 1 2 1

한 수 앞을 더 볼 경우
26
1 1 1 1 2 1
```

### 최종 접근

결국 이와 같은 논리대로면, 몇 수 앞을 더 본다 해도 결국 전체를 보지 못하면 언제든지 같은 논리로 반례를 만들 수 있을 것이다. 때문에 전체를 볼 수 있게끔 문제를 풀어야 했다.

전체를 봐야 한다는 사실을 새로 알았지만, 그래도 여전히 변하지 않는 사실이 하나 있다. 다음 사건을 처리하기 위해 경찰차가 이동해야 하는 거리는, 결국 현재 경찰차의 위치에 따라 결정된다는 점이다.  
따라서 DP의 상태를, **직전 경찰차의 배치를 활용해** 계산한다는 발상을 할 수 있다.

극도로 단순하게 생각하면, 각 사건을 해결할 때마다 직전에 경찰차가 있을 수 있는 배치는 각 $N^4$이다. 자연스레 이는 현재 범위에서 처리 불가능한 시간/공간 복잡도임을 알 수 있고, $N^4$의 모든 배치가 필요한 건 아님을 알 수 있다.  
모든 상황에서 경찰차는 모두 시작점에 있거나, 어떤 사건을 하나 처리한 상태이다. 이때 **한 경찰차는 바로 직전의 사건을 처리했기에 그 사건이 발생한 위치에 있다**는 것을 생각하면, 각 사건마다 고려해야 하는 경우가 $2N^2$으로 줄어든다. (경찰차1이 직전 사건을 처리한 경우 $N^2$, 경찰차2가 직전 사건을 처리한 경우 $N^2$)

여전히 각 사건마다 $2N^2$가지 경우를 다 처리해주면 시간복잡도가 $O\left( 2N^2W \right)$이기 때문에 아직 많이 빡빡하다. 더 효율적으로 계산해야 한다.  
$w$번째 사건을 처리한 직후 어떤 상황을 생각해보자. ($1 \leq w \leq W$) 그러면, 그 사건을 처리한 경찰차는 당연히 $w$번째 사건이 발생한 위치에 있을 것이다.  
그럼 다른 경찰차는 어디에 있을까? 자연스레 **초기 위치에 있거나, 그 이전 사건 중 하나가 발생한 위치에 있을 것이다.**  
이를 활용하면, $w$번째 사건을 처리한 경찰차 2가지에 대해서 나머지 경찰차가 있을 수 있는 위치가 총 $w$가지이므로, 각 사건마다 $2w$가지의 배치가 가능하며, $O \left( W^2 \right)$의 공간복잡도가 나옴을 알 수 있다.

그럼 이제 점화관계를 생각할 수 있다. DP 상태는 $dp[d][w][k]$로 생각할 수 있을 것이다. 그 값은 $w$번째 사건까지 처리한 상황에서, $d$번 경찰차가 그 사건이 발생한 위치에 있고, 다른 경찰차는 $k$번째 사건이 발생한 위치에 있을 때, 총 경로 길이의 최솟값이다. 이때 $0 \leq k < w$이다.  
달리 말하면, $dp[d][w][k]$는 $d$번 경찰차는 $w$번째 사건이 발생한 위치에, 다른 경찰차는 $k$번채 사건이 발생한 위치에 있을 때, $w$번째 사건까지 처리했을 때 총 경로 길이의 최솟값이다.  
단, 여기서 한 경찰차가 $w$번째 사건을 처리할 때까지 움직이지 않는 상황을 정하기 위해, $k=0$의 경우 사건의 위치는 경찰차의 초기 위치로 설정했다. 당연히 그 위치는 $d$가 얼마냐에 따라 달라질 것이다.

이때 $dp[d][w][k]$의 값을 일반적인 DP하듯이 이전 항의 조합으로 계산하려고 했더니 생각이 잘 안 되었다.  
그래서 기저 상태를 먼저 설정해주고, 나머지 DP 배열의 값은 전부 INF로 둔 다음, 각 _이미 채워진_ DP값에 대해 그 값이 영향을 주는 다음 DP값을 업데이트해주는 방식을 사용했다.  
조금 더 구체적으로 설명하자면, $dp[d][w][k]$의 값을 이미 알고 있을 때, $dp[d][w+1][k]$와 $dp[!d][w+1][w]$의 값 각각을 $dp[d][w][k]+dist$와 비교해서 최솟값으로 각각을 갱신해주는 방식으로 DP 배열을 채웠다.  
여기서 $!d$는 $d$번 경찰차의 상대 경찰차를 의미하고, $dist$는 각 경우에서 움직일 경찰차가 움직여야 하는 거리를 의미한다.  
또한, $dp[d][w+1][k]$는 $d$번 경찰차가 $w+1$번째 사건을 처리한 경우를, $dp[!d][w+1][w]$는 $!d$번 경찰차가 $w+1$번째 사건을 처리한 경우를 의미한다.

이와 같은 방법을 사용할 경우 $O \left( W^2 \right)$ 칸의 배열에 대해 각각 $O\left(1\right)$의 연산을 사용해 업데이트 해주므로, 시간/공간 복잡도는 $O \left( W^2 \right)$가 나온다.
이후 실제로 어떤 경찰차가 움직였는지 역추적하는 것은, DP 배열과 크기가 같은 역추적 배열을 추가로 선언해 DP배열의 값에서 갱신이 발생할 때마다 역추적 배열에 이를 기록하면 해결된다.

## 코드

```go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"strconv"
)

//------
// Main
//------

type Pos struct {
	r, c int64
}

func Abs(a int64) int64 {
	if a < 0 {
		return -a
	}
	return a
}

func dist(a, b Pos) int64 {
	return Abs(a.r-b.r) + Abs(a.c-b.c)
}

func main() {
	sc.Split(bufio.ScanWords)
	defer wr.Flush()

	N, W := nextInt64(), nextInt()
	list := make([]Pos, W+1)
	list[0] = Pos{0, 0}
	for i := 1; i <= W; i++ {
		list[i] = Pos{nextInt64(), nextInt64()}
	}

	getList := func(i, w int) Pos {
		if w == 0 {
			if i == 0 {
				return Pos{1, 1}
			}
			return Pos{N, N}
		}
		return list[w]
	}

	back := make([][]int, W+1)
	for w := range back {
		back[w] = make([]int, 2*w)
	}

	dp := make([][]int64, W+1)
	for w := range dp {
		dp[w] = make([]int64, 2*w)
	}
	for i := range dp {
		for j := range dp[i] {
			dp[i][j] = math.MaxInt64 / 2
		}
	}

	dp[0] = append(dp[0], 0)
	dp[1][0] = dist(list[1], Pos{1, 1})
	dp[1][1] = dist(list[1], Pos{N, N})

	for w := 1; w < W; w++ {
		for x, v := range dp[w] {
			var id1, id2 int
			if x < w {
				id1, id2 = w, x
			} else {
				id1, id2 = x-w, w
			}
			// 다음 사건을 경찰차1이 처리한 경우
			newId1 := w + 1
			oneDist := dist(getList(0, id1), getList(0, newId1)) + v
			oneIdx := id2
			if dp[w+1][oneIdx] > oneDist {
				dp[w+1][oneIdx] = oneDist
				back[w+1][oneIdx] = x
			}
			// 다음 사건을 경찰차2가 처리한 경우
			newId2 := w + 1
			twoDist := dist(getList(1, id2), getList(1, newId2)) + v
			twoIdx := w + 1 + id1
			if dp[w+1][twoIdx] > twoDist {
				dp[w+1][twoIdx] = twoDist
				back[w+1][twoIdx] = x
			}
		}
	}

	var ans int64 = math.MaxInt64
	var idx int = 0
	for i, v := range dp[len(dp)-1] {
		if ans > v {
			ans = v
			idx = i
		}
	}
	fmt.Fprintln(wr, ans)

	res := make([]int, W)
	for i := range res {
		w := W - i
		if idx < w {
			res[i] = 0
		} else {
			res[i] = 1
		}
		idx = back[w][idx]
	}

	for i := W - 1; i >= 0; i-- {
		fmt.Fprintln(wr, res[i]+1)
	}
}

//---------
// Fast IO
//---------

var sc = bufio.NewScanner(os.Stdin)
var wr = bufio.NewWriter(os.Stdout)

func nextInt() int {
	sc.Scan()
	text := sc.Text()
	v, _ := strconv.Atoi(text)
	return v
}

func nextInt64() int64 {
	sc.Scan()
	text := sc.Text()
	v, _ := strconv.ParseInt(text, 10, 64)
	return v
}
```

위 코드에서 DP 배열의 인덱싱을 글에서 설명한 것과 조금 다르게 했다.  
코드에선 DP 배열을 이차원 배열로 선언하여, $dp[w][x]$에서 $0 \leq x < w$라면 $w$번째 사건은 경찰차1이 처리하고 경찰차2는 $x$번째 사건이 발생한 위치에 있는 것이고, $w \leq x < 2w$라면 $w$번째 사건은 경찰차2가 처리하고 경찰차1은 $x-w$번째 사건이 발생한 위치에 있는 것이다.  
초기 발상은 위와 같이 전체 경찰차 배치를 하나의 인덱스로 생각했기에 코드 역시 그렇게 작성되었다. 이렇게 작성하면 더 헷갈리기만 하고 별다른 메리트는 없다.
