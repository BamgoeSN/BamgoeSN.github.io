---
layout: post
title: "[BOJ 26089] 완전한 수열 리버스"
date: 2023-10-01 21:00:00 +0900
categories: ["BOJ"]
katex: true
description: " "
---

# 문제

[26089번: 완전한 수열 리버스](https://www.acmicpc.net/problem/26089)

# 풀이

<p>
<details>
<summary>태그</summary>
ad_hoc, constructive, bruteforcing, precomputation
</details>
</p>

2는 유일한 짝수 소수입니다. 2보다 큰 짝수는 전부 합성수입니다. 또한, 출력할 수열에 0도 써넣을 수 있으며, 0 역시 합성수입니다. 이 성질을 활용해 봅시다.

수열이 0과 2로만 이뤄져 있다면, 길이가 소수이면서 합이 2인 부분 수열만이 완전한 수열입니다. 또한, 가능한 수열의 가짓수는 2<sup><i>N</i></sup>으로, *N*이 크지 않다면 브루트포스로 가능한 모든 *M*에 대해 조건을 만족하는 수열을 찾아낼 수 있습니다.

*N ≤ M*이라는 제약을 걷어내고, 0과 2로만 수열을 만들었을 때 각 *N*에 대해 가능한 최대 *M*을 계산해 보면 아래와 같습니다.

| *N*                    | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  |
| ---------------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| <i>M</i><sub>max</sub> | 0   | 1   | 3   | 4   | 6   | 7   | 10  | 12  | 15  | 18  | 20  | 22  | 25  | 28  |

*N*의 값이 커졌을 땐 브루트포스로 정답을 찾는 게 어려우므로, 좀 더 나아가서 생각해야 합니다. 크기 *N*인 수열을 더 작게 쪼개서 작은 *N*에 대한 문제로 바꿀 수 있다면 어떨까요? 쪼개진 구간이 0과 2로만 이뤄져 있고, 각 구간 사이에 4와 같이 합성수인 짝수가 들어가면, 쪼개진 구간들은 서로를 간섭하지 못합니다. 따라서, *N*이 클 경우엔 4를 칸막이로 써서 작은 구간들로 나눈 다음, 각 구간을 0과 2로 채워서 조건을 만족하는 수열을 만들 수 있습니다.

예를 들어서 문제에서 주어진 *N*이 30이  라고 합시다. 구간을 6개 단위로 나눠서 풀어볼게요. 우선 길이 *N*의 배열을 전부 0으로 초기화하고, `7*i - 1`번 인덱스에 4를 집어넣습니다. 그러면 아래와 같이 이 배열은 길이가 6이면서 값이 전부 0인 구간 여러 개를 갖게 됩니다.
```
0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 0
```
0으로 이루어진 길이 6의 구간들에 2를 적절히 채워서, 각 구간 안의 완전한 부분 수열이 0~7개가 되도록 자유롭게 조절할 수 있습니다. 이 방법을 통해 *M*의 값이 7×4 = 28 이하인 모든 경우에 대해선 답을 출력할 수 있습니다. 마지막의 0 2개까지 채우면 *M*이 29인 경우도 커버할 수 있고요. 다만 *M*이 30인 경우는 이 방법으론 안 되고, 마지막 4를 지워서 끝의 연속된 0을 9개로 만들면 가능합니다.

구현을 편하게 할 수 있도록 연속된 0의 개수 단위를 정하고 싶습니다. 가능하면 끝에 남은 0도 활용 안 해도 되게 하고 싶습니다. 그럴 수 있으려면, 연속된 0의 구간 길이를 <i>M</i><sub>max</sub> ≥ 2*N*이 되는 거로 잡으면 됩니다. 그래야 문제에서 주어진 *N*이 그 길이 이상일 때, 연속된 0 구간의 길이를 *A*라 할 때 길이가 *A*인 연속 0 구간에 2를 배치하는 방식만 가지고 답을 만들어낼 수 있습니다. 즉, *A*가 14가 되도록 하면 됩니다.

예를 들어 *N*과 *M*이 모두 60이면 다음과 같이 하면 됩니다. 우선 아래와 같이 전부 0인 배열 중간에 칸막이 4를 집어넣습니다. 4 사이에는 14개의 0이 있습니다.
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4
```
60 = 28×2 + 4이므로, 첫 2개의 0 구간에는 완전한 부분 수열이 각각 28개가 되도록, 그 다음 0 구간에는 4개가 되도록 배치하면 됩니다. 길이가 14이고 0과 2로만 이뤄져 있으면서 완전한 부분 수열이 28개인 수열은 `0 2 0 0 0 0 2 0 0 0 0 2 0 0`이고, 4개인 수열은 `2 2 2 2 2 0 0 0 0 0 0 0 0 0`입니다. (각각 유일하진 않습니다) 이에 따라서, 전자를 첫 2개의 0 구간에 넣고, 후자를 그다음 0 구간에 넣은 아래 수열은 완전한 부분 수열이 60개이면서 길이가 60인 수열이 됩니다.
```
0 2 0 0 0 0 2 0 0 0 0 2 0 0 4 0 2 0 0 0 0 2 0 0 0 0 2 0 0 4 2 2 2 2 2 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4
```

*N* ≤ 15일 땐 위 방법을 사용하면 되고, *N* ≥ 14일 땐 전처리한 값들을 사용하면 됩니다. 단, 브루트포스를 돌려보면 *N*과 *M*이 각각 4, 3일 땐 0과 2만으로는 조건을 만족하는 수열을 만들지 못한다는 결과가 나옵니다. 이 경우는 손으로 수열을 직접 만들어서 따로 처리해 주면 됩니다. *N*이 작기 때문에 할 만합니다.

# 코드
```py
# 전처리 내용 - p[n][m]은 길이 n이고 완전한 부분 수열의 개수가 m인 수열
# p[14]의 모든 수열은 0과 2로만 이뤄져 있음

def solve(n, m):
    if n <= 14:
        return p[n][m]
    else:
        ans = (([0] * 14 + [4]) * n)[:n]
        rem = m
        for l in range(0, n, 15):
            if rem == 0:
                break
            ans[l : l + 14] = p[14][min(rem, 28)]
            rem -= min(rem, 28)
        return ans

n = int(input())
m = int(input())
print(*solve(n, m))
```