---
layout: post
title: "[BOJ 19134] $2x+2$"
date: 2022-05-21 17:00:00 +0900
categories: ["BOJ"]
tags: ["Math", "Ad Hoc"]
katex: true
description: " "
---

# 문제

[19134번: $2x+2$](https://www.acmicpc.net/problem/19134)

Petrozavodsk Programming Camp 문제입니다. 출처가 무섭지만 그거 치고는 난이도가 그렇게 높은 문제는 아닙니다.

# 풀이

## $S$를 만들어가는 과정 관찰

$S$를 만들어가는 과정은 1 이상 $n$ 이하의 자연수에서 문제의 조건을 만족하게끔 최대한 많은 수를 골라서 $S$에 넣는 것으로 생각할 수 있습니다. 그렇기 때문에 제일 먼저 1부터 시작해서 수를 하나씩 돌아보며, 이 수를 포함하면 어떤 수를 포함하지 못하게 되는지 관찰하는 것으로 시작할 수 있습니다.

우선 1부터 봐서, $S$에 넣을 수로 1을 선택할지 말지를 생각해봅시다. 1의 포함 여부는 4의 포함 여부를 결정합니다. $S$에 들어갈 수로 1을 고르게 되면 4는 고를 수 없게 되니까요. 만약 1을 고르지 않았다고 하면, 4를 고를 수도 안 고를 수도 있게끔 선택권이 열리게 되는데, 이때 4의 포함 여부는 10의 포함 여부를 결정합니다.

1의 포함 여부는 4의 포함 여부를 결정하고, 4의 포함 여부는 10의 포함 여부를 결정하고, 10의 포함 여부는 22의 포함 여부를 결정하고... 이와 같이 각 수의 포함 관계가 **사슬**과 같이 연쇄적으로 서로 영향을 줌을 파악할 수 있습니다. 이와 같이 $x \rightarrow 2x+2$로 연쇄적으로 연결되는 수들을 하나의 **사슬**로 보겠습니다.

여기서 이 사슬은 수가 $n$을 넘어가면 사슬이 끊어집니다. 예를 들어서 $n=25$라면 1에서부터 시작하는 사슬은 22에서 끊깁니다. 그러면 1에서부터 시작하는 사슬의 길이는 4가 되겠죠.

## 하나의 사슬에서 최대한 많은 수를 고르는 방법

그럼 다른 수는 전부 무시하고, 1로부터 시작하는 1 - 4 - 10 - 22 - ...의 사슬에 있는 수 중에서 $S$에 들어갈 수를 고르는데, 이때 이 사슬에서 최대한 많은 수를 고르는 방법을 생각해보겠습니다. 사슬에 있는 두 인접한 수는 앞의 수가 골라지면 뒤의 수는 고를 수 없습니다. 예를 들어 4를 고르게 되면 10은 고를 수 없습니다. 따라서 사슬에서 $S$에 들어갈 수를 고를 땐 **서로 인접한 두 수를 고를 수 없습니다**.

그러면 한 사슬에서 인접한 두 수를 고르지 않은 채로 가장 많은 수를 뽑는 방법은 무엇일까요? 당연히 맨 앞의 수를 고르고, 하나 건너뛴 후 다음 수를 고르고, 하나 또 건너뛰고 다음 수를 고르고 하는 것을 반복하면 사슬에서 최대한 많은 수를 고를 수 있을 겁니다. 예를 들어 사슬이 1 - 4 - 10 - 22 - 46에서 끊긴다면, 1, 10, 46을 고르는 것이 최대한 많은 수를 고르는 것일 겁니다.

이를 일반화하면, 어떤 사슬에 대해 그 사슬에서 $S$에 들어가는 원소를 최대한 많이 뽑는 방법은, 그 사슬에서 $2i$번 인덱스에 있는 수를 고르는 것으로 생각할 수 있습니다. 여기서 인덱스는 0부터 시작합니다.

## 다른 수에서 시작하는 사슬

$S$에 포함될 수를 하나의 사슬에서 고를 때엔, 사슬의 길이만 알면 $S$에 들어갈 수의 개수의 최댓값을 사슬의 길이만을 통해서 구할 수 있었습니다. 그러면 나머지 수도 사슬로 생각하면 편하게 문제를 풀 수 있지 않을까요? $n$ 이하의 모든 자연수를 여러 개의 사슬로 쪼개서 본다면, 고를 수 있는 수의 개수의 최댓값은 각 사슬에서 고를 수 있는 개수의 최댓값을 모두 더한 값이라고 생각해볼 수 있으니까요.

다만, 사슬의 개수가 여러 개일 때엔 상황이 조금 더 복잡해집니다. 만약 여러 개의 사슬에서 겹치는 수가 있으면, 각 사슬이 서로 독립적이지 않게 되므로 단순히 각 사슬의 최댓값을 더할 수 없게 됩니다. 따라서, **쪼개고 난 뒤의 각 사슬에는 서로 겹치는 수가 하나도 없어야 합니다.**

이를 염두에 두고, $n$ 이하의 모든 자연수를 사슬로 쪼개보겠습니다. 1부터 시작해서 1로 시작하는 사슬을 써내려가는 것으로 시작하여, 그 다음 수로 시작하는 사슬을 추가하는 것을 반복하는 식으로 사슬을 만들어보겠습니다. 단, 사슬이 서로 겹치면 안 되기 때문에, 이를 최대한 피하기 위해 **이전에 등장했던 수에 대해선 거기서 시작하는 사슬을 추가하지 않겠습니다.**

우선 1로 시작하는 사슬을 적어봅니다.

$$ 1 \rightarrow 4 \rightarrow 10 \rightarrow 22 \rightarrow \cdots $$

다음으로 2를 봅니다. 2는 이전 사슬에 등장하지 않았으므로, 2로 시작하는 사슬을 새로 추가합니다.

$$ 2 \rightarrow 6 \rightarrow 14 \rightarrow 30 \rightarrow \cdots $$

다음으로 3을 봅니다. 3도 마찬가지로 이전 사슬에 등장하지 않았으므로 3으로 시작하는 사슬을 새로 추가합니다.

$$ 3 \rightarrow 8 \rightarrow 18 \rightarrow 38 \rightarrow \cdots $$

다음으로 4를 봅니다. 4는 1에서 시작하는 사슬에 이미 등장했습니다. 따라서 4는 건너뜁니다.

다음으로 5를 봅니다. 5는 이전 사슬에 등장한 적이 없으므로 5로 시작하는 사슬을 추가합니다.

$$ 5 \rightarrow 12 \rightarrow 26 \rightarrow 54 \rightarrow \cdots $$

6은 이미 2로 시작하는 사슬에 등장했고, 7은 등장한 적 없으므로 7로 시작하는 사슬을 추가합니다.

$$ 7 \rightarrow 16 \rightarrow 34 \rightarrow 70 \rightarrow \cdots $$

8은 이미 3으로 시작하는 사슬에 등장했고, 9는 등장한 적 없으므로 9로 시작하는 사슬을 추가합니다.

$$ 9 \rightarrow 20 \rightarrow 42 \rightarrow 86 \rightarrow \cdots $$

이렇게 써내려가다보면 의문점이 두 가지 들 수 있습니다. 첫째로, 모든 사슬은 서로 겹치는 수가 없어야 한다는데, 사슬의 시작점을 이전에 등장하지 않은 수로 하는 게 충분하냐는 점입니다. 둘째로, 사슬의 시작점이 1, 2, 3, 5, 7, 9와 같이 2 또는 모든 홀수가 된다는 점인데, 사슬의 시작점이 이렇게 있으면 모든 자연수를 포함할 수 있냐는 점입니다. 직관적으로 그럴 거라고 생각하고 넘겨도 좋지만, 이 글에서는 일단 이를 증명해보겠습니다.

모든 수에 대해서는 사슬 다음 수뿐만 아니라 사슬 _이전_ 수도 결정지을 수 있고, 이는 유일합니다. 예를 들어, 34가 포함된 사슬에서 34 이전의 수는 $2x+2 = 34$를 만족하는 $x$인 16으로 유일합니다. 이는 기존 수에 2를 뺀 후 2로 나누면 됩니다. 단, 그 수가 4 이상인 짝수여야 이전 수가 존재합니다.

이와 같이 4 이상의 모든 짝수에 대해서는 "이전 수"라는 걸 정의할 수 있고, 본래의 수보다 그 이전 수는 언제나 더 작습니다. 따라서, 어떤 수에 대해서든 그 이전 수의 이전 수, 그 이전 수를 계속 생각해볼 수 있고, 반복할 때마다 수가 점점 작아지며, 그러다가 이전 수가 존재하지 않게 되면, 즉 그 수가 2 또는 홀수가 되면, 그 수가 기존 수가 포함된 사슬의 시작점이 됩니다.

모든 수에 대해 이전 수는 유일하게 정해지므로, 모든 수에 대해 사슬의 시작점도 유일하게 정해집니다. 때문에 모든 사슬의 시작점이 2 또는 홀수라면, 모든 자연수에 대해 그 자연수를 포함하는 사슬은 유일하게 정해집니다.

따라서, 시작점이 2 또는 홀수인 사슬을 모두 모아놓으면, 이 사슬은 $n$ 이하의 모든 자연수를 한 번씩 지나칩니다. 한 번씩만 지나치므로, 각 사슬에서 고를 수 있는 개수의 최댓값을 모두 더하면 그게 정답이 됩니다.

예를 들어 $n=20$이면, $n$ 이하의 모든 자연수는 아래와 같은 사슬로 분해됩니다.

$$
1 \rightarrow 4 \rightarrow 10\ ; \ 2 \rightarrow 6 \rightarrow 14\ ; \ 3 \rightarrow 8 \rightarrow 18 ; \\\\
5 \rightarrow 12\ ; \ 7 \rightarrow 16\ ; \ 9 \rightarrow 20\ ; \\\\
11\ ; \ 13\ ; \ 15\ ; \ 17\ ; \ 19
$$

각 사슬에서 $2i$번 인덱스에 있는 수만 고르면 그 총 개수는 14입니다. 따라서 입력이 20일 때 정답은 14입니다. 그러면 일반적인 $n$에 대해서도 존재하는 모든 사슬에 대해 각각에서 최대한 많은 수를 고르고 그 총 개수의 합을 계산하면 답이 나올 겁니다.

## 더블 카운팅

여기까진 다 좋은데, 문제가 있습니다. 사슬의 시작점은 $n$ 이하의 모든 홀수와 2이므로, 사슬의 총 개수가 $O(n)$입니다. 하지만 이 문제에서 $n$의 값은 최대 ${10}^{100}$입니다. 각 사슬을 일일이 돌면서 수를 고르는 방식은 무리가 있습니다. 그럼 어떻게 해야 할까요?

일단 지금까지 전개한 논리를 식으로 표현해봅시다. 식으로 표현하면 식을 변형하는 게 더 명료하니까요. $k$로 시작하는 수열의 $i$번 인덱스에 해당하는 수를 $a_k [i]$라고 씁시다. 그러면 우리가 구하고자 하는 값은 아래와 같이 정리됩니다.

- 각 $k$에 대해 $a_k[2i] \leq n$인 $i$의 개수 전부 더함

여기서 $i$는 음이 아닌 정수이고, $k$는 사슬의 시작점이므로 1, 2, 3, 5, 7, 9, ...와 같은 수입니다.

여기서 한 가지 관찰을 해볼 수 있습니다. $a_k[i]$의 점화식은 $a_k[i+1] = 2a_k[i] + 2$로, 이전 항에 2를 곱한 뒤 거기에 2를 더 더합니다. 여기서부터 우리는 $a_k[i]$가 등비급수보다도 빠르게 증가함을 예상할 수 있습니다. 따라서 사슬의 시작점 $k$는 많을 수 있어도, 뒤의 "$a_k[2i] \leq n$인 음이 아닌 정수 $i$"는 아무리 많아봤자 $O(\log{n})$ 수준일 것임을 예상할 수 있습니다. 따라서 위 식을 각 $k$에 대해 계산하는 것이 아닌, **각 $i$에 대해 계산**하는 것으로 바꾸면 훨씬 빠르게 계산할 수 있겠다는 생각을 할 수 있습니다. 이를 적용하면 위 문장은 아래와 같이 변형됩니다.

- 각 $i$에 대해 $a_k[2i] \leq n$인 $k$의 개수 전부 더함

이와 같이 더하는 수의 기준을 뒤집는 테크닉을 **더블 카운팅**이라고 부릅니다. 더블 카운팅을 잘 모른다면 다음 글을 참고하세요: [Double Counting과 Harmonic Lemma](https://xy-plane.tistory.com/17) 이 풀이에선 harmonic lemma는 활용하지 않습니다.

이렇게 되면 주어진 음이 아닌 정수 $i$에 대해 $a_k[2i] <= n$을 만족하는 $k$의 개수를 구하면 되는 겁니다. 이를 계산해야 하는 $i$의 개수가 $O(\log{n})$ 수준일 것이기 때문에, 위 식을 토대로 계산하면 기존 식보다 훨씬 빠르게 답을 낼 수 있을 겁니다. 이를 계산하는 방법을 생각해보기 위해 $a_k[i]$의 일반항을 구해봅시다.

## 사슬의 일반항

사슬의 수는 점화식 $a_k[i+1] = 2a_k[i] + 2$로 계산됩니다. 그러면 우리는 이 점화식에 대한 일반항을 구하면 됩니다.

위와 같이 수열의 다음 항이 이전 항의 상수배에 어떤 상수를 더한 값으로 정의되면, 점화식의 양변에 적당한 수를 더해 등비수열의 점화식을 만듦으로써 일반항을 찾을 수 있습니다. 점화식의 양변에 2를 더하면

$$ a_k[i+1] + 2 = 2 \left( a_k[i] + 2 \right) $$

가 됩니다. 여기서 새로운 수열 $b_k[i] = a_k[i]+2$를 정의하면

$$ b_k[i+1] = 2 b_k[i] $$

을 얻습니다. 즉, $b_k[i]$는 $i$에 대해 공비가 2인 등비수열입니다. 초항은 $b_k[0] = a_k[0] + 2 = k+2$이므로

$$ b_k[i] = \left( k + 2 \right) \cdot 2^{i} $$

입니다. 따라서 $a_k[i]$의 일반항은

$$ a_k[i] = \left( k + 2 \right) \cdot 2^{i} - 2$$

입니다. 즉, 아래 값을 구하면 문제가 풀립니다.

- 각 $i$에 대해 $\left( k + 2 \right) \cdot 2^{2i} - 2 \leq n$를 만족하는 $k \in \left\\{ 1, 2, 3, 5, 7, 9, 11, 13, \cdots \right\\} $의 개수 전부 더함

## 최종 계산

이제 저 식을 계산하기 편한 식으로 정리해서 코드만 쓰면 끝입니다. 부등식을 정리해봅시다.

$$
\left( k + 2 \right) \cdot 2^{2i} - 2 \leq n \\\\
\left( k + 2 \right) \cdot 4^{i} \leq n + 2 \\\\
k + 2 \leq \frac{n + 2}{4^i} \\\\
k + 2 \leq \left\lfloor \frac{n + 2}{4^i} \right\rfloor \\\\
k \leq \left\lfloor \frac{n + 2}{4^i} \right\rfloor - 2
$$

따라서 우리는, $i$를 0부터 시작해서 1씩 늘려가며, $k \leq \left\lfloor {n + 2} / {4^i} \right\rfloor - 2$인 $k$의 개수를 계산하면 됩니다. $k$의 값은 2 또는 임의의 홀수가 가능하므로, 우변의 값을 계산하고 나면 부등식을 만족하는 $k$의 개수는 쉽게 셀 수 있습니다. 구체적으로, $\left\lfloor {\left(n + 2\right)} / {4^i} \right\rfloor - 2 = X$라고 한다면

$$
\\# \ of \ k = \begin{cases}
  \left\lfloor \frac{X+1}{2} \right\rfloor + 1 & \text{if}\ X \geq 3 \\\\
  \max{\left(X,0\right)} & \text{otherwise}
\end{cases}
$$

가 되고, 이를 $i=0$부터 시작해서 $i$를 하나씩 올려가며, 부등식을 만족하는 $k$의 개수가 0이 될 때까지 반복해주면 됩니다. 계산될 $i$의 개수는 $O(\log{n})$이므로, 이 알고리즘은 시간 제한 안에 돌 수 있습니다.

# 코드
```python
ans = 0
i = 0
while True:
    x = ((n+2) >> (2*i)) - 2
    if x <= 0:
        break
    elif x >= 3:
        ans += (x+1)//2 + 1
    else:
        ans += x
    i += 1
```

