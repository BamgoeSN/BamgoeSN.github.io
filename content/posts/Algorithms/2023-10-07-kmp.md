---
layout: post
title: "KMP Formalized"
date: 2023-10-07 01:45:00 +0900
categories: ["Algorithms"]
katex: true
description: " "
---

\* 아래 글은, KMP에 대한 설명을 말과 그림으로 들으니 막상 구현할 때 계속해서 오류가 나는 분들을 위한 글입니다.

KMP 알고리즘은 문자열 $P$를 문자열 $T$ 안에서 빠르게 검색하는 알고리즘입니다. KMP는 $P$ 안의 부분문자열이 반복되는 구조를 활용하는데, 이는 DP의 일종으로 계산이 가능합니다. KMP의 DP식을 어느정도 엄밀하게 정리해두면 구현할 때 편리하기 때문에 여기에 메모합니다.

아래 설명에서 부분문자열은 Python의 슬라이싱 문법을 사용해서 표현합니다. 예를 들어, $P[:i]$는 $P$의 길이 $i$인 접두사이고, $P[j:i]$는 $P$의 $j$번째 문자부터 $j-i$개의 문자를 포함하는 부분문자열입니다.


# KMP의 실패함수

문자열 $P$에 대해, $P[:i]$의 접두사와 접미사가 같은 것들 중 가장 길면서 $P[:i]$ 자체는 아닌 것의 길이를 $c_i$라고 정의합시다. 즉, 수열 $\{c_i\}$를 다음과 같이 정의합니다.

- $c_0 = 0$이다.
- $P[i-j:i] = P[:j]$를 만족하면서 $i$보다는 작은 가장 큰 수 $j$를 $c_i$로 정의한다. ($0 \le i \le \left\| P \right\|$)

이 수열 $\{ c_i \}$를 **실패함수**라고 부릅니다. $c_i$는 DP를 통해 계산할 수 있는데, 이 방법은 후술하겠습니다.


# KMP에서의 문자열 검색

문자열 $P$와 $T$에 대해, $P$의 접두사와 $T[:i]$의 접미사가 같은 것들 중 가장 긴 것의 길이를 $d_i$라고 정의합시다. 즉, 수열 $\{d_i\}$를 다음과 같이 정의합니다.
다음과 같은 수열 $\{d_i\}$를 정의합니다.

- $d_0 = 0$이다.
- $T[i-j:i] = P[:j]$를 만족하는 가장 큰 $j$를 $d_i$로 정의한다. ($0 \le i \le \left\| T \right\|$)

$\{c_i\}$의 정의와 유사하지만 $i<j$의 조건이 없고, 등식에서 좌변의 $P$가 $T$로 바뀌었습니다. 이렇게 정의된 $d_i$는, $d_i = \left\| P \right\|$인 모든 $i$에 대해 $T[i - \left\| P \right\|] = P$를 만족하므로, $T$ 안에서 $P$가 부분문자열로 나타나는 위치는 $d_i = \left\| P \right\|$인 $d_i$라고 볼 수 있습니다. 따라서, $d_i$를 구하면 $T$에서 모든 $P$를 검색하는 셈이 됩니다.

$c_i$와 정의가 유사한 만큼 $d_i$도 DP로 계산할 수 있습니다.


# KMP의 상태 전이식

$c_i$보다 $d_i$가 더 단순하므로 $d_i$를 계산하는 알고리즘부터 알아보겠습니다.

## 문자열 검색 - $d_i$ 계산

수열 $\{c_i\}$를 이미 다 계산한 상태에서, $d_i$의 값으로부터 $d_{i+1}$을 계산하는 방법을 알아봅시다.

$d_i$는 다음과 같은 의미를 갖습니다.

- $P[:d_i] = T[i - d_i : i]$

여기서 좌변에 수열 $\{c_i\}$의 정의를 적용해봅시다. $P[:d_i]$의 접미사인 $P[d_i - c_{d_i}:d_i]$는 실패함수의 정의에 의해 그 접두사 $P[:c_{d_i}]$와 같습니다. 따라서, 다음과 같은 식을 얻습니다.

- $P[:c_{d_i}] = P[d_i - c_{d_i}:d_i] = T[i-c_{d_i}:i]$

이 식은 재귀적으로 적용이 가능합니다. 계속해서 적용하다보면 문자열의 길이가 점점 짧아지다가 그 길이가 $0$이 되는 시점이 옵니다.

- $P[:c_{c_{d_i}}] = T[i - c_{c_{d_i}}:i]$
- $P[:c_{c_{c_{d_i}}}] = T[i - c_{c_{c_{d_i}}}:i]$
- $P[:c_{c_{c_{c_{d_i}}}}] = T[i - c_{c_{c_{c_{d_i}}}}:i]$
- $\qquad \vdots$

위와 같이 재귀적으로 나오는 등식들을 갖고 $d_{i+1}$를 계산할 수 있습니다. 우선, 만약 $P[d_i] = T[i]$이라면, $P[:d_i] = T[i-d_i:i]$이므로 $P[: d_i+1] = T[i-d_i : i+1]$입니다. 따라서, 이 경우엔 $d_{i+1} = d_i+1$임을 알 수 있습니다.

만약 $P[d_i + 1] \ne T[i+1]$이라면, 그 다음 등식인 $P[:c_{d_i}] = T[i-c_{d_i}:i]$를 활용합니다. 만약 $P[c_{d_i}] = T[i]$이면, 앞서 한 것과 동일한 원리로 $P[:c_{d_i}+1] = T[i - c_{d_i} : i+1]$이므로, $d_{i+1} = c_{d_i}+1$임을 알 수 있습니다.

이와 같은 비교를 계속해서 반복하면 $d_{i+1}$의 값을 알 수 있게 됩니다. 만약 끝까지 문자 매칭에 실패하면 $\{d_i\}$의 정의를 따라 $d_{i+1} = 0$이라 하면 됩니다. 즉, 전체 알고리즘은 아래와 같은 형태를 갖게 됩니다.

1. $T[i] = P[d_i]$면 $d_{i+1} = d_i + 1$이라 하고 알고리즘을 종료한다.
2. $T[i] = P[c_{d_i}]$면 $d_{i+1} = c_{d_i} + 1$이라 하고 알고리즘을 종료한다.
2. $T[i] = P[c_{c_{d_i}}]$면 $d_{i+1} = c_{c_{d_i}} + 1$이라 하고 알고리즘을 종료한다.
2. $T[i] = P[c_{c_{c_{d_i}}}]$면 $d_{i+1} = c_{c_{c_{d_i}}} + 1$이라 하고 알고리즘을 종료한다.
2. $T[i] = P[c_{c_{c_{c_{d_i}}}}]$면 $d_{i+1} = c_{c_{c_{c_{d_i}}}} + 1$이라 하고 알고리즘을 종료한다.
3. $\qquad \vdots$
4. $T[i] = P[0]$이면 $d_{i+1} = 1$이라 하고 알고리즘을 종료한다.
5. $P$의 인덱스가 $0$이 되었는데도 $T[i]$와 다른 문자가 나온다면 $d_{i+1} = 0$이다.

한 가지 예외를 더 챙겨줘야 하는데, $d_i = \left\| P \right\|$인 경우 이미 $T$ 안에서 $P$를 하나 찾은 상황이고 $P[d_i]$가 $P$의 영역 밖이기 때문에, 이 경우 위 알고리즘에서 첫 번째 줄을 건너뛰고 두 번재 줄부터 시행하면 됩니다.

이 알고리즘의 구현은 아래와 같습니다.

```python
# P, T: 문자열 P와 T
# c: P에 대한 수열 c
m = len(T)
d = [0]
for i in range(m):
    x = d[i]  # P의 인덱스로 사용할 변수, 반복적으로 x = c[x]를 해줄 것
    if x == len(P):
        x = c[x]
    while True:
        if T[i] == P[x]:  # 매칭 성공
            d.append(x + 1)
            break
        if x == 0:  # x가 0이 될 때까지 맞은 게 하나도 없음
            d.append(0)
            break
        x = c[x]  # 재귀적으로 인덱스 변경
```

## 실패함수 - $c_i$

실패함수의 정의는 $d_i$의 정의와 거의 같기 때문에 동일한 원리를 적용할 수 있습니다. 수열 $\{c_i\}$의 값을 $c_i$까지 알고 있을 때 $c_{i+1}$의 값을 구하기 위해선 $P[c_i] = P[i]$를 확인하고, 매칭되지 않으면 $P[c_{c_i}] = P[i]$를 확인하고, 하는 것을 반복하면 됩니다.

단, $d_i$의 계산에 썼던 코드를 그대로 쓰면 $c_i = i$가 나와버립니다. 이는 해당 코드가 $\{c_i\}$의 정의에 있는 "$i$보다는 작은"이라는 문구를 무시하기 때문입니다. 이는 $c_1 = 0$이라는 초기값을 추가로 주면 해결됩니다.

```python
# P: 문자열 P
n = len(P)
c = [0, 0]  # c[1] == 0
for i in range(1, n):
    x = c[i]  # P의 인덱스로 사용할 변수
    # x가 len(P)와 같아질 일이 없으므로 해당 체크는 패스
    while True:
        if P[i] == P[x]:  # 매칭 성공
            c.append(x + 1)
            break
        if x == 0:
            c.append(0)
            break
        x = c[x]  # 재귀적으로 인덱스 변경
```


# 예제 - [BOJ 1786 찾기](https://www.acmicpc.net/problem/1786)

위 코드를 그대로 쓰면 됩니다.

```python
T = input()
P = input()

n = len(P)
c = [0, 0]  # c[1] == 0
for i in range(1, n):
    x = c[i]  # P의 인덱스로 사용할 변수
    # x가 len(P)와 같아질 일이 없으므로 해당 체크는 패스
    while True:
        if P[i] == P[x]:  # 매칭 성공
            c.append(x + 1)
            break
        if x == 0:
            c.append(0)
            break
        x = c[x]  # 재귀적으로 인덱스 변경

m = len(T)
d = [0]
for i in range(m):
    x = d[i]  # P의 인덱스로 사용할 변수
    if x == len(P):
        x = c[x]
    while True:
        if T[i] == P[x]:  # 매칭 성공
            d.append(x + 1)
            break
        if x == 0:  # x가 0이 될 때까지 맞은 게 하나도 없음
            d.append(0)
            break
        x = c[x]  # 재귀적으로 인덱스 변경

ans = []
for i, v in enumerate(d):
    if v == len(P):  # T[v-len(P):v] == P
        ans.append(i - len(P) + 1)  # 출력 결과는 1-based index여서 1을 더함
print(len(ans))
print(*ans)
```