---
layout: post
title: "벡터로 두 선분의 교차점 구하기"
date: 2023-10-28 01:30:00 +0900
categories: ["Algorithms"]
tags: ["Geometry"]
katex: true
description: " "
---

* 이 글에선 편의상 두 점을 잇는 벡터는 화살표 없이 $AB$와 같이 표현합니다.

기하 문제를 풀 때 벡터를 활용하면 복잡한 좌표 계산이나 생전 처음 들어보는 논증기하 법칙을 쓰지 않고도 다양한 기하 문제를 풀 수 있습니다. 또한, case work를 하는 양이 줄어들기도 하고, case 몇 개를 빼먹는 실수도 줄여주기도 합니다.

이 글에서 그 예시로 선분 교차를 판정하고, 교차한다면 그 교점을 구하는 알고리즘을 벡터를 활용해 구성해보려고 합니다.

구성하는 과정이 싫고 바로 알고리즘 요약으로 넘어가고 싶으시면, 글 하단에 [알고리즘만 요약해놓은 문단이 있습니다.](#알고리즘-정리)

# 벡터와 선분

혹시 벡터에 대해 잘 모르시거나, 벡터의 외적을 처음 들어보셨거나, 벡터로 선분을 표현한다는 말을 처음 들어보신 분들이시라면 아래 글을 꼭 읽어보세요. 굉장히 좋은 글입니다. \
[https://zigui.tistory.com/34](https://zigui.tistory.com/34)

말씀드린 세 가지 내용은 이 알고리즘을 구성하는 과정에서 사용되는 것들입니다. 이 글에서는 벡터의 외적과 선분의 벡터 표현 정도만 간단히 기술하겠습니다.

두 벡터를 곱하는 방법으로 알려진 건 크게 두 가지가 있는데, 그중 하나가 외적(cross product)입니다. 두 평면벡터를 외적하게 되면 벡터가 아닌 그냥 수 하나가 나오게 되는데, 이는 다음과 같이 정의됩니다.

$$ (a_x, a_y) \times (b_x, b_y) = a_x b_y - a_y b_x $$

외적은 다음과 같은 성질을 갖습니다.

- 결합법칙과 분배법칙을 만족합니다.
- 외적하는 두 벡터를 교환하면 부호가 반대가 됩니다. 즉, $\vec{a} \times \vec{b} = - \vec{b} \times \vec{a}$입니다.
- 평행한 두 벡터를 외적하면 $0$입니다.
- 같은 벡터를 외적하면 $0$입니다. 즉, $\vec{a} \times \vec{a} = 0$입니다.

한편, 두 점 $A$, $B$를 양끝 점으로 같는 선분 위의 임의의 점 $X$에 대해, 벡터 $OX = \vec{x}$는 다음과 같이 표현할 수 있습니다.

$$ \vec{x} = OA + sAB \quad (0 \le s \le 1) $$

다른 게 아니라, 원점 $O$에서 점 $X$로 가려면 $A$로 먼저 간 다음, $AB$를 따라 일정 수준 이동하면 된다는 뜻입니다. 이 식은 $A$와 $B$를 잇는 선분 위의 모든 점을 정확하게 표현해주기 때문에, 선분을 이와 같은 벡터를 활용한 식으로 표현했다고도 할 수 있습니다.


# 알고리즘 구성

이제 선분 교차 알고리즘에 대해 알아봅시다.

<center><img src="/assets/posts/2023-10-27-line-intersection/1.jpg" width="400"></center>

위 그림과 같이 두 선분 $P_0 P_1$과 $Q_0 Q_1$이 주어졌을 때 그 교점 $R$이 존재하는지, 존재한다면 어떤 점인지 구할 방법을 생각해봅시다. 이는 벡터 $OR$이 만족하는 방정식을 써서, 그 식을 만족하는 변수가 존재하는지 확인하고 존재한다면 그 값을 구하는 것으로 수행할 수 있습니다.

교점 $R$이 존재한다면 벡터 $P_0 R$이 다음 두 식을 동시에 만족하게 하는 두 실수 $s$, $t$가 존재합니다.

$$
\begin{aligned}
P_0 R &= s P_0 P_1 &\quad (0 \le s \le 1) \\\\
P_0 R &= P_0 Q_0 + t Q_0 Q_1 &\quad (0 \le t \le 1) \\\\
\end{aligned}
$$

<center><img src="/assets/posts/2023-10-27-line-intersection/2.jpg" width="400"></center>

이 그림이 바로 보이지 않는다 하더라도, 점 $R$이 두 선분 $P_0 P_1$과 $Q_0 Q_1$ 모두 위에 있다는 점을 활용해서 식을 쓰고 이를 정리하면 위 식을 얻을 수 있습니다.

식을 정리하면 이렇습니다.

$$ s P_0 P_1 - t Q_0 Q_1 = P_0 Q_0 \quad (0 \le s, \; t \le 1) $$

위 식에서부터 $s$와 $t$를 계산하고자 합니다. 좌표 단위로 찢어서 두 식을 놔도 되지만, 같은 벡터를 서로 외적하면 $0$이 된다는 성질을 활용하면 더욱 쉽게 $s$와 $t$를 계산할 수 있습니다.

우선 $s$를 계산하기 위해 양변에 $Q_0 Q_1$을 외적해봅시다.

$$ s (P_0 P_1 \times Q_0 Q_1) = (P_0 Q_0 \times Q_0 Q_1) $$

위 식을 활용하면, $(P_0 P_1 \times Q_0 Q_1) \ne 0$이라면 $s$의 값이 바로 나옵니다. $t$에 대한 식도 비슷하게 양변에 $P_0 P_1$을 외적하면 얻을 수 있습니다.

$$ -t (Q_0 Q_0 \times P_0 P_1) = t (P_0 P_1 \times Q_0 Q_1) = (P_0 Q_0 \times P_0 P_1) $$

마찬가지로, $(P_0 P_1 \times Q_0 Q_1) \ne 0$이라면 $t$의 값이 바로 나옵니다. $s$의 값을 식으로부터 계산할 수 있는 경우와 요구하는 조건이 같네요.

여기서 케이스를 둘로 나눠봅시다. $(P_0 P_1 \times Q_0 Q_1) \ne 0$인 경우와 아닌 경우로 나눕시다.

## 두 선분이 평행하지 않을 때

$(P_0 P_1 \times Q_0 Q_1) \ne 0$인 경우는 두 선분 $P_0 P_1$과 $Q_0 Q_1$이 둘 다 길이가 $0$이 아니고 평행하지 않은 경우에 해당합니다. 이 경우엔 앞서 나온 식으로 $s$와 $t$를 바로 계산할 수 있습니다.

$$
s = \frac{(P_0 Q_0 \times Q_0 Q_1)}{(P_0 P_1 \times Q_0 Q_1)} \qquad t = \frac{(P_0 Q_0 \times P_0 P_1)}{(P_0 P_1 \times Q_0 Q_1)}
$$

$s$, $t$가 모두 $0$ 이상 $1$ 이하면 교점 $R$이 존재하는 것이며, 그 좌표는 $OR = OP_0 + s P_0 P_1$로 구할 수 있습니다.

## 그 외의 모든 경우

$(P_0 P_1 \times Q_0 Q_1) = 0$인 경우는, 앞서 기술한 케이스 외의 모든 케이스입니다. 여기에는 두 선분이 평행한 경우와, 둘 중 길이가 $0$인 선분이 있는 경우가 속합니다.

제일 먼저, 네 점이 한 직선 위에 있는지부터 판단해야 합니다. 이는 $P_0$, $P_1$, $Q_0$, $Q_1$ 중 3개의 점을 고르는 4가지 경우 전부에 대해 선택한 세 점이 한 직선 위에 있는지 판별하면 됩니다. 즉, 아래 네 가지 식을 전부 확인하면 됩니다.

$$ P_0 P_1 \times P_1 Q_0 = 0 \quad P_0 P_1 \times P_1 Q_1 = 0 \quad P_0 Q_0 \times Q_0 Q_1 = 0 \quad P_1 Q_0 \times Q_0 Q_1 = 0 $$

아마 이 중 3개만 확인해도 충분할 것 같은데, 제대로 확인해보지 않았습니다. 또한, 길이 $0$인 직선이 없음이 보장되어 있으면 앞의 2개만 해도 충분할 겁니다.

위 네 식 중 하나라도 사실이 아니면 네 점이 한 직선 위에 있지 않은 건데, 두 선분이 평행하지 않은 경우는 걸렀기 때문에 이 경우는 반드시 두 선분이 평행하면서 만나지 않는 경우입니다. 따라서 이 경우엔 교점이 존재하지 않습니다.

<center><img src="/assets/posts/2023-10-27-line-intersection/3.jpg" width="450"></center>

그럼 이제 네 직선이 한 선분 위에 있는 경우만 판별하면 됩니다. 여기서부턴 벡터를 안 쓰는 게 편리한 것 같습니다.

$A_0, \, A_1 = \min(P_0, \, P_1) \; \max(P_0, \, P_1)$로 두고, $B_0, \, B_1 = \min(Q_0, \, Q_1), \; \max(Q_0, \, Q_1)$로 둡니다. 여기서 두 좌표의 대소 비교는 $x$좌표가 작은 것이 작고, 그 값이 같다면 $y$좌표가 작은 것이 작은 것으로 합니다. 그러면 $A_0 \rightarrow A_1$의 방향과 $B_0 \rightarrow B_1$의 방향이 일치하게 됩니다.

그런 다음, $L = \max(A_0, \, B_0)$, $R = \min(A_1, \, B_1)$로 두면, 선분 $LR$이 두 선분이 서로 교차하는 영역이 됩니다. 단, $L \le R$인 경우에만 교차하는 영역이 존재하며, $L > R$이면 위 그림과 같이 두 선분이 교차하지 않는 것에 해당합니다.

# 알고리즘 정리

- 입력 - 두 선분 $P_0 P_1$과 $Q_0 Q_1$
- 출력 - 두 선분의 교점이 있으면 그 교점을, 두 선분이 한 선분으로 겹치면 그 선분을 반환하며, 두 선분이 만나지 않으면 만나지 않는다고 판단한다.

1. $u \leftarrow (P_0 P_1 \times Q_0 Q_1)$
1. $u \ne 0$이라면,
   1. $s \leftarrow (P_0 Q_0 \times Q_0 Q_1) / u \qquad t \leftarrow (P_0 Q_0 \times P_0 P_1) / u$
   1. $0 \le s \le 1$이고 $0 \le t \le 1$이면 두 선분은 $OP_0 + sP_0P_1$에서 교차한다. 그렇지 않으면 교점이 없다.
1. 그렇지 않다면,
   1. $P_0 P_1 \times P_1 Q_0 = 0$, $P_0 P_1 \times P_1 Q_1 = 0$, $P_0 Q_0 \times Q_0 Q_1 = 0$, $P_1 Q_0 \times Q_0 Q_1 = 0$ 중 하나라도 거짓이면 교점이 없다.
   1. $A_0, \, A_1 \leftarrow \min(P_0, \, P_1), \; \max(P_0, \, P_1) \qquad B_0, \, B_1 \leftarrow \min(Q_0, \, Q_1), \; \max(Q_0, \, Q_1)$
   1. $L \leftarrow \max(A_0, \, B_0) \qquad R \leftarrow \min(A_1, \, B_1)$
   1. $L < R$이면 선분 $LR$에서 겹치고, $L = R$이면 $L$이 교점이고, $L > R$이면 교점이 없다.

# 오버플로우 주의

해당 알고리즘을 적용할 때, 정수 자료형만을 사용해 정확한 교점을 구하고자 하는 상황이면 두 선분이 평행하지 않는 경우에서 오버플로우를 주의해야 합니다. 그 부분에서 $s$나 $t$의 값은 두 벡터의 외적으로 구해지고, 거기에 벡터를 곱해서 교점의 좌표를 구하게 되는데, 주어진 점의 좌표의 절댓값이 ${10}^9$ 이하라면 이 교점의 분자, 분모의 절댓값은 최대 ${10}^{27}$까지 증가할 수 있습니다.

따라서, 점의 좌표가 `i32` 범위라면 교점의 좌표를 구할 때 `i128`까지 자료형을 확장해야 합니다. 정확한 교점이 필요한 건 아니라면 적절할 때에 `f64`로 바꿔줘야 합니다.

만약 교점의 좌표를 알 필요가 없이 두 선분이 만나는지만 알고 싶으면, 점의 좌표 범위가 `i32` 수준일 때 `i64` 내에서만 계산을 하면 됩니다. $s$와 $t$의 값만 확인하면 되니까요.

아니면 파이썬을 쓰세요.

# 코드
```py
from fractions import Fraction

def sub(a, b): return (a[0]-b[0], a[1]-b[1])
def cross(a, b): return a[0]*b[1] - a[1]*b[0]

def intersect(p, q):
    u = cross(sub(p[1], p[0]), sub(q[1], q[0]))
    if u != 0:
        sn = cross(sub(q[0], p[0]), sub(q[1], q[0]))
        tn = cross(sub(q[0], p[0]), sub(p[1], p[0]))
        if (0<=sn<=u or u<=sn<=0) and (0<=tn<=u or u<=tn<=0):
            s, t = sn, u-sn
            g, h = p
            x, y = Fraction(t*g[0] + s*h[0], u), Fraction(t*g[1] + s*h[1], u)
            return x, y
        else:
            return None
    else:
        pts = [*p, *q]
        three = [[pts[0], pts[1], pts[2]], [pts[0], pts[1], pts[3]], \
            [pts[0], pts[2], pts[3]], [pts[1], pts[2], pts[3]]]
        if any(map(lambda l: cross(sub(l[0], l[1]), sub(l[1], l[2])) != 0, three)):
            return None
        a0, a1 = min(p), max(p)
        b0, b1 = min(q), max(q)
        l, r = max(a0, b0), min(a1, b1)
        if l < r:
            return [l, r]
        elif l == r:
            return l
        else:
            return None
```
